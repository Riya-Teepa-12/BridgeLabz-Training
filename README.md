# ğŸ“… Week 3 â€“ Day 1  
## ğŸ“Œ Topic: Linked Lists (Singly, Doubly & Circular)

This module focuses on understanding and implementing different types of **Linked Lists**, a core Data Structures concept.  
The objective is to strengthen traversal logic, pointer manipulation, and CRUD operations using real-world problem statements.

---

## ğŸ”— Linked List Types Covered

### 1ï¸âƒ£ Singly Linked List
Each node contains:
- Data
- Reference to the next node

**Operations Implemented:**
- Add node at:
  - Beginning  
  - End  
  - Specific position  
- Delete node by ID  
- Search node by ID or Name  
- Update node data  
- Display all nodes  

**Use Case Examples:**
- Student Record Management  
- Inventory Management System  
- Employee Management System  

---

### 2ï¸âƒ£ Doubly Linked List
Each node contains:
- Data
- Reference to the previous node
- Reference to the next node

**Operations Implemented:**
- Add node at beginning, end, or specific position  
- Remove node by unique ID  
- Search by title or author  
- Update availability/status  
- Display list:
  - Forward traversal  
  - Backward traversal  

**Use Case Example:**
- Library Management System  

---

### 3ï¸âƒ£ Circular Linked List
The last node points back to the first node instead of `null`.

**Operations Implemented:**
- Add node at the end  
- Remove node by unique ID  
- Search by customer name or category  
- Display all nodes in circular manner  

**Use Case Example:**
- Online Ticket Reservation System  

---

## ğŸ¯ Learning Outcomes
- Understand differences between Singly, Doubly, and Circular Linked Lists  
- Implement efficient traversal and deletion logic  
- Handle edge cases (empty list, single node, head/tail deletion)  
- Apply linked list concepts to real-world problems  
- Improve problem-solving and pointer manipulation skills  

---

## ğŸ› ï¸ Tech Stack
- **Language:** Java  
- **IDE:**  Eclipse  
- **Input Handling:** Scanner (No hard-coded values)  

**Code Link**
[LinkedList](https://github.com/Riya-Teepa-12/BridgeLabz-Training/tree/dsa-practice/dsa-practice/gcr-code-base/DSA/src/com/linkedlist)


**ğŸ—“ï¸ Day 2: Stack, Queue, HashMap & Hashing Function**
ğŸ”¹ Topics Covered

-Stack

-Queue

-HashMap

-Hashing Function

**ğŸ“Œ 1. Stack**

A Stack is a linear data structure that works on the LIFO (Last In, First Out) principle. The element inserted last is removed first. All operations happen from one end called the top.

âœ” Key Operations

-Push â€“ Insert an element at the top

-Pop â€“ Remove the top element

-Peek / Top â€“ View the top element without removing it

-isEmpty â€“ Check whether the stack is empty

âœ” Applications

Function call management (Call Stack)

-Undo / Redo functionality

-Expression evaluation and parenthesis checking

**ğŸ“Œ 2. Queue**

A Queue is a linear data structure that follows the FIFO (First In, First Out) principle. The element inserted first is removed first. Insertion happens at the rear, and deletion happens from the front.

âœ” Key Operations

-Enqueue â€“ Insert an element at the rear

-Dequeue â€“ Remove an element from the front

-Peek / Front â€“ View the front element

-isEmpty â€“ Check whether the queue is empty

âœ” Types of Queues

-Simple Queue

-Circular Queue

-Priority Queue

-Deque (Double Ended Queue)

âœ” Applications

-CPU scheduling

-Task and request handling

-Printer queue

-Breadth First Search (BFS)

**ğŸ“Œ 3. HashMap**

A HashMap is a data structure that stores data in key-value pairs. It uses a hashing technique to provide fast access to values based on keys.

âœ” Features

-Average time complexity of O(1) for insert, delete, and search

-Keys are unique

-Values can be duplicated

âœ” Common Operations

-put(key, value) â€“ Insert a key-value pair

-get(key) â€“ Retrieve value using key

-remove(key) â€“ Delete a key-value pair

-containsKey(key) â€“ Check if a key exists

âœ” Applications

-Frequency counting problems

-Caching data

-Indexing and lookup tables

-Solving array and string problems efficiently

**ğŸ“Œ 4. Hashing Function**

A Hashing Function converts a given key into an index of a hash table where the corresponding value is stored.

âœ” Characteristics of a Good Hash Function

-Uniform distribution of keys

-Minimizes collisions

-Fast computation

âœ” Collision Handling Techniques

-Chaining

-Open Addressing

-Linear Probing

-Quadratic Probing

**ğŸ¯ Learning Outcome**

-Clear understanding of Stack and Queue operations

-Learned how HashMap works internally using hashing

-Understood the role of hashing functions and collision handling

**ğŸš€ Next Steps**

Practice implementation-based and problem-solving questions using Stack, Queue, and HashMap to strengthen DSA fundamentals.

**Code Link**
[Stack , Queue and HashMap](https://github.com/Riya-Teepa-12/BridgeLabz-Training/tree/dsa-practice/dsa-practice/gcr-code-base/DSA/src/com)




